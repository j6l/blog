{"posts":[{"title":"Docker中文控制面板","content":"Docker控制面板 docker的中文面板。操作简单，易上手。官网链接：https://www.dockernb.com/ 安装命令 docker run --restart always -p 8081:8081 -d -v /var/run/docker.sock:/var/run/docker.sock wangbinxingkong/fast 用户初始账户为：admin/用户初始密码为：888888 ","link":"https://j6l.5431998.xyz/post/DockerMb/"},{"title":"JPA入门","content":"jpa yml spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/day07?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC type: com.alibaba.druid.pool.DruidDataSource username: root password: root jpa: hibernate: ddl-auto: update #创建时根据entity调整数据库 show-sql: true #控制台显示sql语句 open-in-view: false pom implementation 'org.springframework.boot:spring-boot-starter-data-jpa' runtimeOnly 'mysql:mysql-connector-java' compile group: 'com.alibaba', name: 'druid', version: '1.2.1' annotationProcessor 'org.projectlombok:lombok:1.18.2' compileOnly 'org.projectlombok:lombok:1.18.2' entity @Entity //标明是表 @Table(name = &quot;e_emp&quot;) //表的名字 @Data public class EEmp { @Id //确认主键 @GeneratedValue //默认自动识别主键增长的状态 private Integer id; //设置表内的名字和长度 不设置的haul 根据驼峰自动转换成蛇形 @Column(name = &quot;name&quot; ,length = 20) private String Name; private String PassWd; private Integer Role; private String Other; } dao @Repository public interface EEmpDao extends JpaRepository&lt;EEmp,Integer&gt; {//第一个类型,第二个主键名 } test private final static Logger log = LoggerFactory.getLogger( DemoApplicationTests.class ); @Autowired EEmpDao empDao; @Test void add(){ EEmp eEmp = new EEmp( 1,&quot;admin&quot;,&quot;123456&quot;, 1,&quot;weixin&quot; ); EEmp save = empDao.save( eEmp ); log.info( save.toString() ); } @Test void update(){ Optional&lt;EEmp&gt; emp = empDao.findById( 1 ); if (emp.isPresent()){ EEmp eEmp = emp.get(); eEmp.setPassWd( &quot;123165165&quot; ); eEmp.setOther( &quot;qq&quot; ); eEmp.setRole( 2 ); empDao.save( eEmp ); } log.info( String.valueOf( empDao.count() ) ); } @Test void select(){ List&lt;EEmp&gt; all = empDao.findAll(); for (EEmp eEmp : all) { System.out.println( eEmp.toString() ); } } @Test void delet(){ empDao.deleteById( 1 ); Optional&lt;EEmp&gt; emp = empDao.findById( 1 ); if (emp.isPresent()) log.error( &quot;失败&quot; ); else log.info( &quot;成功&quot; ); } ","link":"https://j6l.5431998.xyz/post/jpa-ru-men/"},{"title":"MYsql入门","content":"查询数据 SELECT id,stuName,age,sex,gradeName FROM t_student; 查询表 SELECT stuName,id,age,sex,gradeName FROM t_student; 按所需顺序查询表 SELECT * FROM t_student; 输出表 SELECT stuName,gradeName FROM t_student; 查询所需的表 SELECT * FROM t_student WHERE id=1; 查询id=1的表 SELECT * FROM t_student WHERE age&gt;22; 查询age&gt;22的表 SELECT * FROM t_student WHERE age IN (21,23); 查询age21到23的表 SELECT * FROM t_student WHERE age NOT IN (21,23); 查询age21到23之外的表 SELECT * FROM t_student WHERE age BETWEEN 21 AND 24; 查询age21或24的表 SELECT * FROM t_student WHERE age NOT BETWEEN 21 AND 24; 查询age不是21或24的表 SELECT * FROM t_student WHERE stuName LIKE '张三'; 查询stuName为张三的表 SELECT * FROM t_student WHERE stuName LIKE '张三%'; %位候补多个字符 SELECT * FROM t_student WHERE stuName LIKE '张三_'; _位候补一个字符 SELECT * FROM t_student WHERE stuName LIKE '%张三%'; 前后都候补多个字符 SELECT * FROM t_student WHERE sex IS NULL; 查询sex为空的表 SELECT * FROM t _student WHERE sex IS NOT NULL; 查询sex不为空的表 SELECT * FROM t_student WHERE gradeName='一年级' AND age=23; 查询为一年级和age23的表 SELECT * FROM t_student WHERE gradeName='一年级' OR age=23; 查询为一年级或age23的表 SELECT DI STINCT gradeName FROM t_student; 去除重复的数据之后排列出来 SELECT * FROM t_student ORDER BY age ASC; age正序排序 SELECT * FROM t_student ORDER BY age DESC; age反序排序 SELECT * FROM t_student GROUP BY gradeName; SELECT gradeName,GROUP_CONCAT(stuName) FROM t_student GROUP BY gradeName; 以gradeName为单位查询出stuName的内容并排列出来 SELECT gradeName,COUNT (stuName) FROM t_student GROUP BY gradeName; 以gradeName为单位查询出stuName的数量 SELECT gradeName,COUNT (stuName) FROM t_student GROUP BY gradeName HAVING COUNT (stuName) &gt;3; 以gradeName为单位查询出stuName的数量大于3的表 SELECT gradeName,COUNT(stuName) FROM t_student GROUP BY gradeName WITH ROLLUP; 以gradeName为单位查询出stuName的数量，输出总计 SELECT gradeName,GROUP_CONCAT(stuName) FROM t_student GROUP BY gradeName WITH ROLLUP; 以gradeName为单位查询出stuName的内容，拼接输出列表 SELECT * FROM t_student LIMIT 0,5; 分页查询0是开头， SELECT * FROM t_student LIMIT 5,5; 第一个数是第几个数据开始， SELECT * FROM t_student LIMIT 10,5; 第二个数是一页显示多少数据，不足不影响 链接查询 EIECT * FROM t_book,t_bookType; 输出两个表 ELECT * FROM t_book,t_bookType WHERE t_book.bookTypeId=t_bookType.id; 输出两个表中这两个元素相同的表 内连接 ELECT bookName,author,bookTypeName FROM t_book,t_bookType WHERE t_book.bookTypeId=t_bookType id; 输出两个表中这两个元素相同的表中这三个元素的表（不用*所有元素） ELECT tb.bookName,tb.author,tby.bookTypeName FROM t_book tb,t_bookType tby WHERE tb.bookIypeId=tby.id; 给表别名，输出这两个元素相同的表中这三个元素的表（避免元素过多混乱，给予表别名） 外连接 ELECT * FROM t_book LEFT JOIN t_bookType ON t_book.bookTypeId=t_bookType.id; 左链接，输出两个列表相同的的行，以左为尊，左边有右边没有右边输出空 ELECT tb.bookdTame,tb.author,tby.bookIypeName FROM t_book tb LEFT JOIN t_bookType tby ON tb.bookTypeId=tby.id; ELECT * FROM t_book RIGHT JOIN t_bookType ON t_book.bookTypeId=t_bookType.id; 右链接，输出两个列表相同的的行，以右为尊，右边有左边没有左边输出空 ELECT tb.bookName,tb.author,tby.bookTypeName FROM t_book tb LEFT JOIN t_bookType tby ON tb.bookTypeId=tby.id; ELECT tb.bookName,tb.author,tby.bookTypeName FROM t_book tb,t_bookType tby WHERE tb.bookTypeId=tby.id AND tb.price&gt;70; 内连接输出p6行的数据且price大于70的数据 函数 SELECI COUNT (*) FROM t _grade; 查询记录数 SELECT COUNT(*) AS total FROM t grade; 给予查询记录数的列表命名 SELECT StuName,COUNT (*) FROM t_grade GROUP BY StuName; 求StuName列表中有多少行数据 SELECT StuName,SUM(score) FROM t_grade WHERE stuName= &quot;张三&quot; ; 求张三score的和 SELECT StuName,SUM (score) FROM t_grade GROUP BY StuName; 求StuName列表中score的和 SELECT StuName,AVG (score) FROM t grade WHERE stuName=&quot;张三&quot;; 求张三score的平均值 SELECT StuName,AVG (score) FROM t_grade GROUP BY StuName; 求StuName列表中score的平均值 SELECT StuName,course,MAX (score) FROM t_grade WHERE stuName=&quot;张三&quot;; 求张三score的最大值 SELECT StuName,MAX (3core) FROM t_grade GROUP BY StuName; 求StuName列表中score的最大值 SELECT StuName,course,MIN (score) FROM t_grade WHERE stuName=&quot;张三&quot;; 求张三score的最小值 SELECT StuName,MIN (score) FROM t_grade GROUP BY StuName; 求StuName列表中score的最小值 子查询 SELECT * FROM t_book WHERE booktypeId IN (SELECT id FROM t_booktype); 查询t_booktype中的id，如果不为空，查询t_book中查询id包含booktypeId的行 SELECT * FROM t_book WHERE booktypeId NOT IN (SELECT id FROM t_booktype); 查询t_booktype中的id，如果不为空，查询t_book中查询id不包含booktypeId的行 SELECT * FROM t_book WHERE price&gt;=(SELECT price FROM t_pricelevel WHERE priceLevel=1); 查询t_book中price大于等于（t_pricelevel的price中priceLevel等于1的值）的结果 SELECT * FROM t_book WHERE EXISTS (SELECT * FROM t_booktype); EXISTS如果子查询的结果不为空，查询主查询（子查询相当于返回一个ture或flase，主查询判断是否输出） SELECT * FROM t_book WHERE NOT EXISTS (SELECT * FROM t_booktype); NOT EXISTS如果子查询的结果为空，主查询输出位空 SELECT * FROM t_book WHERE price&gt;= ANY (SELECT price FROM t_pricelevel); ANY满足任一条件成立 SELECT * FROM t_book WHERE price&gt;= ALL (SELECT price FROM t_pricelevel); ALL满足全部条件成立 合并查询别名 合并查询 SELECT id FROM t_book; 查询t_book中id表； SELECT id FROM t_booktype; 查询t_booktype中id表； SELECT id FROM t_book UNION SELECT id FROM t_booktype; 两个表一起查询，去除重复的结果 SELECT id FROM t_book UNION ALL SELECT id FROM t_booktype; 两个表一起查询，输出所有结果 给表取别名 SELECT * FROM t_book WHERE id=1; 查询t_book中id等于1的表 SELECT * FROM t_book t WHERE t.id=1; 给t_book取别名t SELECT t.bookName FROM t_book t WHERE t.id=1; 查询t_book中id等于1的t_bookName元素 SELECT t.bookName bName FROM t_book t WHERE t.id=1; 查询t_book中id等于1的t_bookName元素并给元素取名bName SELECT t.bookName AS bName FROM t_book t WHERE t.id=1; 等同上一条 改变数据 插入数据 INSERT INTO t_book VALUES(NULL,'我爱我家',20'张三',1); 插入一条数据 INSERT INTO t_book (id,bookName,price,author,bookTypeId) VALUES(NULL,'我爱我家',20'张三',1); 插入一条制定位置的数据 INSERT INTO t_book (bookName,author) VALUES('我爱我家','张三'); 插入一条不完整的数据 INSERT INTO t_book (id,bookName,price,author,bookTypeId) VALUES (NULL,'我爱我家',20'张三',1),(NULL,'我爱我家2',20'张三',1),(NULL,'我爱我家3',20'张三',1) 插入多条数据 更新数据 属性名 内容 属性名 内容 条件 UPDATE t_book SET bookName='java编程思想'，price=120 WHERE id=1; 改变条件内的所需更改的内容 UPDATE t_book SET bookName=我' WHERE bookName LIKE '%我爱我家%'； 符合条件的多个元素一起改变 DELETE FROM t_book WHERE id=5；删除id=5的这条数据 可以删除多条数据，只要条件符合全部删除 DELETE FROM t_book WHERE bookName='我'; 删除bookName等于我数据 索引 索引 定义：索引是由数据库表中一列或者多列组合而成，其作用的提高对表中数据的查询速度； 类似于图书目录 优点：提高查询数据的速度 缺点：创建和维护索引的时间增加 1,普通索引 这类索引可以创建在任何数据类型中; 2,唯一性索引 使用UNIQUE 参数可以设置，在创建唯一性索引时，限制该索引的值必须是唯一的; 3，全文索引 使用FULLTEXT 参数可以设置，全文索引 只能创建在CHAR,VARCHAR,TEXT 类型的字段上。主要作用就是提高查询较大字符串类型的速度; 4,单列索引 在表中可以给单个字段创建索引，单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引; 5,多列索引 多列索引是在表的多个字段上创建一个索引; 6,空间索引 使用SPATIAL 参数可以设置空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率;只有MyISAM 引擎支持该索引，Mysql 默认引擎不支持; 创建索引表 CREATE TABLE mytable(id INT, 普通索引 username VARCHAR(20), PASSWORED VARCHAR(20), INDEX (userName) ); CREATE TABLE mytable2(id INT, username VARCHAR(20), PASSWORED VARCHAR(20), UNIQUE INDEX index_usName(userName) 唯一性索引 别名 ); CREATE TABLE mytable3(id INT, 多列索引 username VARCHAR(20), PASSWORED VARCHAR(20), INDEX index_usName_password(userName,PASSWORED) ); 在已存在的表建立索引 CREATE INDEX index_usName ON mytable4(userName); 普通索引 CREATE UNIQUE INDEX index_usName ON mytable4(userName); 唯一性索引 CREATE INDEX index_usName_password ON mytable4(userName,PASSWORED); 多列索引 ALTER TABLE创建索引 ALTER TABLE mytable5 ADD INDEX index_usName(userName); 普通索引 ALTER TABLE mytable5 ADD UNIQUE INDEX index_usName(userName); 唯一性索引 ALTER TABLE mytable5 ADD INDEX index_usName_password(userName,PASSWORED); 多列索引 删除索引 索引名字 所在表 DROP INDEX index_usName ON mytable5; 视图 视图 是一种虚拟的表，数据库中止存放了视图的定义，显示的数据是原来表中的数据 使用便捷，增加数据安全性，提高表的逻辑独立性 单表创建 CREATE VIEW v1 AS SELECT * FROM t_book; 创建t_book表的全部内容的视图取名v1 SELECT * FROM v1; 查询视图v1； CREATE VIEW v2 AS SELECT bookName,price FROM t_book; 取bookName，price两个元素创建v2视图 CREATE VIEW v3(b,p) AS SELECT bookName,price FROM t_book; 创建视图v3，给bookName，price两个元素取别名（b，p），给bookName，price两个元素取别名（b，p） 多表创建 CREATE VIEW v4 AS SELECT bookName,bookTypeName FROM t_book,t_booktybe WHERE t_book.bookTypeId=t_booktybe.id; 创建视图v4，在两个表内查询bookName，bookTypeId的内容，输出条件bookTypeId与id相等的内容 CREATE VIEW v5 AS SELECT tb.bookName,tby.bookTypeName FROM t_book tb,t_booktybe tby WHERE tb.bookTypeId=tby.id; 查看识图信息 DESCRIBE v5; 查看视图v5（可简写DESC） SHOW TABLE STATUS LIKE 'v5'; 查看视图v5的基本信息 SHOW TABLE STATUS LIKE 't_book'; 查看视图t_book的基本信息与v5做对比 SHOW CREATE VIEW v5; 查看v5的详细信息 修改视图 SELECT * FROM v1; 显示视图v1 CREATE OR REPLACE VIEW v1(bookName,price) AS SELECT bookName,price FROM t_book; 修改v1表中的显示出来的元素（类别，多少），并定向到t_book中的相应元素 ALTER VIEW v1 AS SELECT * FROM t_book; 修改视图，如果没有相应的视图不能完成，上面的没有视图可以完成创建 更新视图 INSERT INTO v1 VALUES(NULL,'java good',120,'fang',1); 通过视图添加数据 修改视图的数据，会直接修改相应表中的数据 UPDATE v1 SET bookName='java very good',price=200 WHERE id=5; 通过WHERE判断修改相应的数据 DELETE FROM v1 WHERE id=5; 删除id=5的数据 删除视图 DROP VIEW IF EXISTS v4; 删除视图v4 触发器 触发器 创建单个触发器 名字 事件后 CREATE TRIGGER trig_book AFTER INSERT ON t_book FOR EACH ROW UPDATE t_bookType SET bookNum=bookNum+1 WHERE new.bookTypeId=t_booktype.id; 执行事件 位置 操作 判断 创建一个trig_book触发器，通过判断，在事件后，于t_bookType执行操作 INSERT INTO t_book VALUES(NULL,'java好',100,'ke',1); 于t_book创建新的内容，通过触发器判断在t_bookType的bookName位置加一 DELIMITER | 内包含多个;号，添加函数是编译器可以识别 CREATE TRIGGER trig_book2 AFTER DELETE ON t_book FOR EACH ROW BEGIN old是发生后的数据定位 UPDATE t_bookType SET bookNum=bookNum-1 WHERE old.bookTypeId=t_bookType.id; INSERT INTO t_log VALUES(NULL,NOW(),'在book表里删除了一条数据'); 在t_log插入数据NOW，NOW()函数当前系统时间 DELETE FROM t_test WHERE old.bookTypeId=t_test.id; END | DELIMITER ； DELETE FROM t_book WHERE id=5; 删除数据验证trig_book2触发器 SHOW TRIGGERS; 查看触发器信息 DROP TRIGGER trig_book2 ; 删除触发器（最后留一个空格） 常用函数 常用函数 返回日期 返回时间 返回月份（1~12） SELECT CURDATE(),CURTIME(),MONTH(birthday) AS m FROM t_t; 字符串长度 全部大写 全部小写 SELECT userName,CHAR_LENGTH(userName),UPPER(userName),LOWER(userName) FROM t_t; 绝对值 开平方 求余 SELECT num,ABS(num),SQRT(9),MOD(9,4) FROM t_t; 加密方式 密码（不可逆） INSERE INTO t_t VALUES(NULL,'2013-1-1','a',1,PASSWORD('123456')); 加密方式 密码（不可逆） INSERE INTO t_t VALUES(NULL,'2013-1-1','a',1,MD5('123456')); 加密方式 密码 密钥（可解密） 必须用BLOB类型字段保存 INSERE INTO t_t VALUES(NULL,'2013-1-1','a',1,MD5('123456')，ENCODE('asdf','aa')); 解密 那类数据，aa密钥 判断哪一行数据 SELECT DECODE(pp,'aa') FROM t_t WHERE id=5; 储存过程 储存过程 DELIMITER &amp;&amp; 变量语句，相当于作为一个函数的开头 CREATE PROCEDURE pro_tt (IN bT INT,OUT count_num INT) 函数语句 储存过程名称（IN(输入参数) 查询名 数据类型，OUT(输出参数) 输出参数名称 类型 ） READS SQL DATA 函数语句读数据(CONTAINS SQL包含sql语句不读写，NO SQL不包含sql，READS SQL DATA读，MODIFIES SQL DATA写，默认第一个) BEGIN 可以包含多条条件语句 SELECT COUNT(*) FROM t_t WHERE num=bT; 条件语句 END &amp;&amp; 变量语句，相当于作为一个函数的结尾 DELIMITER ; CALL pro_tt(1,@tot); （输入条件，写的话全局变量不写局部变量） 函数 DELIMITER &amp;&amp; CREATE FUNCTION func_tt (bookID INT) 函数语句 函数名 返回值+类型 RETURNS VARCHAR(20) RETURNS type sql支持类型都可以返回 BEGIN RETURN (SELECT userName FROM t_t WHERE id=bookID); return返回需要的结果 END &amp;&amp; DELIMITER ; SELECT func_tt(2); 查询函数的结果 变量 DELIMITER &amp;&amp; CREATE PROCEDURE pro_user() BEGIN DECLARE a,b VARCHAR (20); 定义变量 类型 INSERT INTO t_user VALUES(NULL,a,b); 传递变量进入t_user END &amp;&amp; DELIMITER ; DELIMITER &amp;&amp; CREATE PROCEDURE pro_user2() BEGIN DECLARE a,b VARCHAR (20); SET a='python1234',b='123456'; 直接定义ab INSERT INTO t_user VALUES(NULL,a,b); END &amp;&amp; DELIMITER ; DELIMITER &amp;&amp; CREATE PROCEDURE pro_user3() BEGIN DECLARE a,b VARCHAR (20); SELECT userName,num INTO a,b FROM t_t WHERE id=2; 读取其他表的值传递过来 INSERT INTO t_user VALUES(NULL,a,b); END &amp;&amp; DELIMITER ; CALL pro_user(); 执行 CALL pro_user2(); 执行 CALL pro_user3(); 执行 游标 DELIMITER &amp;&amp; CREATE PROCEDURE pro_user4() BEGIN DECLARE a,b VARCHAR (20); DECLARE cur_t CURSOR FOR SELECT userName,num FROM t_user2; 创建游标 DECLARE 流标名 CURSOR FOR 选择语句 OPEN cur_t; 打开游标 FETCH cur_t INTO a,b; 使用游标 INSERT INTO t_user VALUES(NULL,a,b); CLOSE cur_t; 关闭游标 END &amp;&amp; DELIMITER ; CALL pro_user4(); 执行 if判断 DELIMITER &amp;&amp; CREATE PROCEDURE pro_user5(IN bookid INT) 定义一个变量 BEGIN SELECT COUNT(*) INTO @num FROM t_user WHERE id=bookid; 定义一个获取的值 IF @num&gt;0 THEN UPDATE t_user SET userName='java1234' WHERE id=bookid; if 条件 then 成立执行语句 ELSE INSERT INTO t_user VALUES(NULL,'asda','asdasdd'); else 执行语句 END IF ; 结束 END &amp;&amp; DELIMITER ; CALL pro_user5(5); 执行 case等同while DELIMITER &amp;&amp; CREATE PROCEDURE pro_user6(IN bookid INT) BEGIN SELECT COUNT(*) INTO @num FROM t_user WHERE id=bookid; CASE @num case 开始 WHEN 1 THEN UPDATE t_user SET userName='java1234da' WHERE id=bookid; when 1 then 执行语句 WHEN 2 THEN INSERT INTO t_user VALUES(NULL,'pythonda','asdasdd122'); when 2 then 执行语句 ELSE INSERT INTO t_user VALUES(NULL,'ccccc','aaaaa'); else 执行语句 END CASE; 结束 END &amp;&amp; DELIMITER ; CALL pro_user6(6); 执行 LOOP循环 不会自动跳出 DELIMITER &amp;&amp; CREATE PROCEDURE pro_user8(IN cuer INT) BEGIN aaa:LOOP SET cuer=cuer-1; IF cuer=0 THEN LEAVE aaa; ELSEIF cuer=3 THEN ITERATE aaa; END IF ; INSERT INTO t_user VALUES(cuer,'pythonda','asdasdd122'); END LOOP aaa ; END &amp;&amp; DELIMITER ; aaa:LOOP 循环语句开头 需要遇见LEAVE aaa才能退出 END LOOP aaa ; 循环语句结尾 ITERATE aaa跳过本次循环 DELETE FROM t_user; 删除表内容 CALL pro_user8(11); 执行 REPEAT循环 有跳出语句 REPEAT SET cuer=cuer-1; 循环减1 INSERT INTO t_user VALUES(cuer,'pythonda','asdasdd122'); 执行语句 UNTIL cuer=1 当cuer=1跳出 END REPEAT; WHILE循环 WHILE cuer&gt;0 DO INSERT INTO t_user VALUES(cuer,'pythonda','asdasdd122'); SET cuer=cuer-1; END WHILE; 查看函数状态 SHOW PROCEDURE STATUS LIKE'pro_tt'; 查看函数定义 SHOW CREATE PROCEDURE pro_tt; 修改函数过程注释 ALTER PROCEDURE pro_tt COMMENT '测试一个COMMENT'; 删除函数过程 DROP PROCEDURE pro_user； 数据备份 mysqldump -u root -p db_book &gt; c:\\db_book.sql 外键 cascade方式 在父表上update/delete记录时，同步update/delete掉子表的匹配记录 set null方式 在父表上update/delete记录时，将子表上匹配记录的列设为null 要注意子表的外键列不能为not null No action方式 如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作 Restrict方式 同no action, 都是立即检查外键约束 Set default方式 父表有变更时,子表将外键列设置成一个默认的值 但Innodb不能识别 ","link":"https://j6l.5431998.xyz/post/mysql-ru-men/"},{"title":"yum update 升级","content":"生产环境对软件版本和内核版本要求非常精确，别没事有事随便的进行yum update操作！！！！！ update yum update：升级所有包同时也升级软件和系统内核 yum upgrade: 升级同时也升级软件和系统内核后 重启验证一下 升级错误后回滚: yum history undo 推荐 //内核部分就过滤掉、不会升级 yum --exclude=kernel* update ","link":"https://j6l.5431998.xyz/post/yum-update-sheng-ji/"},{"title":"UFW的简单使用","content":"UFW 简单介绍 ufw 是一个主机端的 iptables 类防火墙配置工具，比较容易上手。一般桌面应用使用 ufw 已经可以满足要求了。 安装方法 sudo apt-get install ufw 使用方法 1. 启用 sudo ufw enable sudo ufw default deny 作用：开启了防火墙并随系统启动同时关闭所有外部对本机的访问（本地访问外部正常） 2. 关闭 sudo ufw disable 3. 查看防火墙状态 sudo ufw status 4. 开启 / 禁用相应端口或服务举例 sudo ufw allow 80 #允许外部访问80端口 sudo ufw delete allow 80 #禁止外部访问80端口 sudo ufw allow from 192.168.1.1 #允许此IP访问所有的本机端口 sudo ufw deny smtp #禁止外部访问smtp服务 sudo ufw delete allow smtp #删除上面建立的某条规则 sudo ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 22 #要拒绝所有的TCP流量从10.0.0.8/8到192.168.0.1地址的22端口 #可以允许所有RFC1918网络（局域网/无线局域网的）访问这个主机（/8，/16，/12是一种网络分级）： sudo ufw allow from 10.0.0.0/8 sudo ufw allow from 172.16.0.0/12 sudo ufw allow from 192.168.0.0/16 推荐设置 sudo apt-get install ufw sudo ufw enable sudo ufw default deny 这样设置已经很安全，如有特殊需要，可以使用 sudo ufw allow 开启相应的服务。 参考 ufw防火墙简单设置 ufw中文使用指南 ","link":"https://j6l.5431998.xyz/post/ufw-de-jian-dan-shi-yong/"},{"title":"CentOS 7更换yum源 安装ufw","content":"更换yum源 1、备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 或 mv /etc/yum/repos.d/CentOS-Base.repo{,.date -I} 2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/ sudo curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 3、添加EPEL curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 4、清理缓存并生成新的缓存 yum clean all yum makecache sudo curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo yum clean all yum makecache 安装ufw sudo yum install wget make wget https://launchpad.net/ufw/0.33/0.33/+download/ufw-0.33.tar.gz tar xzf ufw-0.33.tar.gz cd ufw-0.33 sudo python ./setup.py install sudo chmod -R g-w /etc/ufw /lib/ufw /etc/default/ufw /usr/sbin/ufw ","link":"https://j6l.5431998.xyz/post/centos-7-yum-yuan-an-zhuang-ufw/"},{"title":"说清楚脏写、脏读、不可重复读、幻读","content":"我们都知道 MySQL 是支持多事务并发执行的，否则一个事务一个事务串行化处理，用户都要砸键盘了。那么，多个事务同时写一行数据怎么处理？一个事务在写数据的时候，另一个事务要读，又该怎么处理这个冲突？为了解决这些问题，MySQL 使用了 MVCC 多版本控制机制、事务隔离机制、锁。 最耳熟能详的就是，事务可以分成 4 个隔离级别：读未提交、读已提交、可重复读、串行化。用的最多的就是 InnoDB 默认的隔离级别——是可重复读 REPEATABLE READ，一般会叫它的缩写「RR」。 🤔 到这里，不知道你有没有产生几个疑问？ 我们知道有事务隔离这回事儿，那为什么要隔离？为什么隔离还不够，还要分级？ 事务隔离级别解决了什么问题？没有解决什么问题？ MySQL 是如何实现这几个隔离级别的呢？它们底层的工作原理是什么呢？ 多个事务并发执行，是怎么一个场景呢？# 不知道你第一次听到「事务隔离机制」的时候是怎么想的，我的第一反应就是：好好的事务，为什么要给它隔离呢？？ 多个事务并发执行的场景是这样的。我们有一个业务系统，里面很多线程在执行业务代码，比如说 Service 去调用 Dao，Dao 去操作数据库。在业务代码层面，对数据库的操作我们可能会给它加上事务，加上事务之后，如果执行成功就 commit，执行失败就要 rollback。 上面这个流程大家肯定很熟了吧。接下来，由于 MySQL 中的数据是保存在磁盘上。但你要知道，随机读磁盘是很耗时间的，对于频繁的 IO 操作，通常的做法就是先把数据加载到内存里面。MySQL 中就有个内存组件 Buffer Pool，执行增删改查的时候，都会把数据从磁盘加载到 Buffer Pool 中，再执行增删改查操作。 现在要来操作内存（Buffer Pool）中的数据了，由于 MySQL 要支持事务，它是通过什么实现事务的呢？这就涉及到 undo log、redo log 来支持 rollback 和 commit 操作了。 上面讲的是一个事务执行的大致流程，那假设这里的每个线程都开启一个事务，那此时就是多个事务并发执行的场景了。 现在你知道多个事务并发执行是怎么一回事儿了，那又有第二个问题了：**多个事务并发又咋了，有什么问题么？又没多吃你家一块肉！**实际上这里是有问题，因为允许多个事务并发执行，那它们就可能同时访问同一行数据，这就会发生并发问题了。 写冲突，多个事务同时对缓存页里面的一行数据进行更新，允许谁来写？这个冲突要怎么解决？可不可以用锁来解决？ 读写冲突，一个事务在写数据，别的事务过来读数据了，这个时候要怎么办？ MySQL 解决它们的方法就是 MVCC 多版本控制机制、事务隔离级别、锁机制，也是后面几篇要介绍的内容。 8 张图告诉你，脏写、脏读、不可重复读、幻读到底是怎么回事儿# 现在你已经知道了多个事务并发执行是怎么样的一个场景，也知道这样会产生各种冲突。有事务在写数据的时候，别的事务要读同一行的数据那怎么办？一个事务写到一半反悔了，要回滚又会产生什么问题？ 这种读写冲突可能导致的问题，前辈都帮我们总结好了，就是脏写、脏读、不可重复读和幻读的问题。 脏写# MySQL 的数据是放在一个个缓存页里面的，然后每个缓存页里面是一行行的数据，就像下面这张图这样： 现在有一个事务 A 正在执行，它执行的是一个写操作，原来有一行数据是 NULL，在它执行了 update 操作，把 NULL 改成了值 A，就像下面这张图这样： 注意，这里事务 A 更新了一行数据但是它并没有提交。紧接着事务 B 也来写这行数据了，这就是多个事务并发执行，还操作同一行数据的场景了。事务 B 做的也是 update 操作，把值 A 改成了值 B，如下图所示： 前面说了事务 A 此时是没有提交的，除了提交事务，还可以干嘛？对了，事务 A 是可以回滚的！回滚意味着什么？回滚是不是就意味着原来那一行数据，要回滚到事务 A 执行之前的那个值，也就是 NULL： 事务 A 回滚了，对于事务 B 意味着什么？事务 B 明明正常写了一行数据，但是写完之后发现值变了，变成一个莫名其妙的值。 这就是脏写，脏写就是说我两个事务来写同一行数据，但是前面的那个事务反悔了，回滚了。在后面的事务 B 眼里，我明明修改了数据，怎么会写错呢？它打算也想不到，是别的事务回滚了。 脏读# 脏读的情况和脏写差不多喽： 事务 A 先写数据，把一行数据的值从 null 改成了 A，同样事务 A 并没有提交； 然后事务 B 过来读了，它读到的值自然是 A 喽； 接着事务 A 又回滚了！回滚之后值就要从 A 变回到 NULL； 事务 B 再去读的时候读到的就是 NULL 了 脏读就是事务 B 因为事务 A 回滚，读不到之前的值了。 不可重复读# 事务 A 先去读一行数据，读到值是 A； 事务 B 去修改数据，改成了 B。这里和前面不一样的地方就在，事务 B 它还提交了，不回滚了。 事务 A 第二次去读，读到的是 B，和第一次读到的 A 不一样。 那不可重复读是指什么？它是指在同一个事务里面查询同一行数据，每次查到的数据都不一样。是不是和脏读很像，区别在于脏读是由于别的事务回滚导致，而不可重复读读到的其实是已经提交的数据。 幻读# 最后就剩下幻读了，前面的脏写、脏读、不可重复读，都是针对一行数据来说的，幻读不一样，幻读是指查到了之前没有的一批数据： 事务 A 里有一个条件查询的语句 select name from t where id &gt; 10，它进行了一次范围查询，查到了 10 行数据； 然后事务 B 网里面加入了一批数据 事务 A 再查的用条件查询语句查询的时候，发现查到了 15 条，其中 5 条是之前没见过的。这个事务 A 以为自己出现幻觉了，怎么会多出这么些个数据？这就是幻读了。 事务隔离机制是如何解决脏写、脏读、不可重复读和幻读问题的# 前面讲到了，多事务并发执行是会带来脏写、脏读、不可重复读和幻读的问题，MySQL 是如何解决这个问题的呢？答案其实每个人都听过，就是使用事务隔离机制，包括 read uncommitted（读未提交），read committed（读已提交），repeatable read（可重复读），serializable（串行化）这几个隔离级别。 我们回过头来看脏写和脏读。它们其实都是后面的事务正常执行，但是前面的事务回滚了导致的。这个时候它们就是处在 read uncommitted（读未提交）这个隔离级别之下，能够读到别人没有提交的事务。 那么现在提高事务的隔离级别，变成 read committed（读已提交）会怎么样呢？比如说脏读，事务 A 修改了值，从 NULL 变成了值 A。这个时候事务 B 来读，由于隔离级别是 RC，事务 A 没有提交事务的情况下，事务 B 是读不到的，也就不存在事务 A 回滚导致事务 B 第二次读到值和第一次不一样了。 不可重复读和幻读则与脏写和脏读有所区别了，它们读到的都是已经提交了的事务。但是在 repeatable read（可重复读）这个隔离级别中，就能够做到事务开启之后，不论别的事务是否提交，它读到的值都和最开始一样。这就要基于 MVCC 多版本控制机制来讲了，在这里先卖个关子，后面会专门写一篇文章来讲 MySQL 的 RR 是如何实现的。 最后就是 serializable（串行化），串行化很好理解，就是一次只能执行一个事务，完全禁止并发，大家排好队一个个执行，啥事儿都没有喽。但实际开发中是不会有人用这个隔离级别的，重点再念一遍「RR」repeatable read（可重复读）。 小结# 先回顾一下，这篇文章先讲了多事务并发执行的场景是怎么样的？紧接着引出了多事务并发可能带来的问题，其中就包括脏写、脏读、不可重复读和幻读。最后介绍了一个事务的隔离级别：read uncommitted（读未提交），read committed（读已提交），repeatable read（可重复读），serializable（串行化），以及它们是如何解决脏写、脏读、不可重复读和幻读问题的。 文章中还留下一个小坑没有填，那就是 MySQL 中最常用到的隔离级别可重复读是怎么实现，MVCC 版本控制机制是到底是什么意思。 原文地址 https://www.cnblogs.com/shuiyj/p/13357612.html ","link":"https://j6l.5431998.xyz/post/shuo-qing-chu-zang-xie-zang-du-bu-ke-chong-fu-du-huan-du/"},{"title":"markdown添加 视频、音频、gif","content":"1.添加 gif &lt;img src=&quot;https://p9-tt-ipv6.byteimg.com/origin/pgc-image/c17158b8445947d2b8d3aacca3507f5c&quot; alt=&quot;show&quot; /&gt; 2.添加 视频 &lt;video id=&quot;video&quot; controls=&quot;&quot; preload=&quot;none&quot; poster=&quot;http://tiebapic.baidu.com/forum/w%3D580/sign=bb699926ecf2b211e42e8546fa816511/dfc8fc256b600c332c15219d0d4c510fd8f9a1a0.jpg&quot; style=&quot;width: 480px;&quot;&gt; &lt;source id=&quot;mp4&quot; src=&quot;https://gss3.baidu.com/6LZ0ej3k1Qd3ote6lo7D0j9wehsv/tieba-smallvideo-transcode-crf/3421479_673e8d6b2388f06ad67ebc99e87ee7c1_0.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt; 3.添加 音频 &lt;audio id=&quot;audio&quot; controls=&quot;&quot; preload=&quot;none&quot;&gt; &lt;source id=&quot;mp3&quot; src=&quot;http://qiniu.cloud.fandong.me/Music_iP%E8%B5%B5%E9%9C%B2%20-%20%E7%A6%BB%E6%AD%8C%20%28Live%29.mp3&quot;&gt; &lt;/audio&gt; ","link":"https://j6l.5431998.xyz/post/markdown-tian-jia-shi-pin-yin-pin-gif/"},{"title":"test贴吧视频","content":" ","link":"https://j6l.5431998.xyz/post/test-tie-ba-shi-pin/"},{"title":"Debian 9 (stretch) 更换为阿里源包","content":"修改/etc/apt/sources.list文件 # 备份原文件，养成好习惯 cp /etc/apt/sources.list /etc/apt/sources.list_back # 编辑/etc/apt/sources.list vim /etc/apt/sources.list 将里面的内容全部替换成： deb http://mirrors.aliyun.com/debian stretch main contrib non-free deb-src http://mirrors.aliyun.com/debian stretch main contrib non-free deb http://mirrors.aliyun.com/debian stretch-updates main contrib non-free deb-src http://mirrors.aliyun.com/debian stretch-updates main contrib non-free deb http://mirrors.aliyun.com/debian-security stretch/updates main contrib non-free deb-src http://mirrors.aliyun.com/debian-security stretch/updates main contrib non-free 保存并更新软件包 : apt-get update ","link":"https://j6l.5431998.xyz/post/debian-ali/"},{"title":"Hello Gridea","content":"😞👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://j6l.5431998.xyz/post/hello-gridea/"}]}